<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Communication - è°ƒè¯•é¢æ¿</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            color: #00ff00;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        h2 {
            color: #ffff00;
            margin: 20px 0 10px 0;
            font-size: 1.1rem;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .panel {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 20px;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
        }

        .dot.connected { background: #00ff00; }
        .dot.active { background: #00ff00; animation: pulse 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .log-container {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            font-size: 12px;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 2px;
        }

        .log-entry.info { color: #00ff00; }
        .log-entry.warn { color: #ffff00; }
        .log-entry.error { color: #ff0000; }
        .log-entry.audio { color: #00ffff; }

        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        label {
            min-width: 150px;
            color: #aaa;
        }

        input[type="range"] {
            flex: 1;
            accent-color: #00ff00;
        }

        input[type="number"], input[type="text"] {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 4px;
            width: 100px;
        }

        input[type="checkbox"] {
            accent-color: #00ff00;
            width: 18px;
            height: 18px;
        }

        button {
            background: #333;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        button:hover {
            background: #00ff00;
            color: #000;
        }

        button.active {
            background: #00ff00;
            color: #000;
        }

        button.danger {
            border-color: #ff0000;
            color: #ff0000;
        }

        button.danger:hover {
            background: #ff0000;
            color: #fff;
        }

        .meter {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .meter-bar {
            flex: 1;
            height: 20px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.05s;
        }

        .meter-value {
            min-width: 50px;
            text-align: right;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat-item {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #888;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .quick-cmd {
            font-size: 11px;
            padding: 5px 10px;
        }

        a {
            color: #00ffff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        .nav {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav">
            <a href="/">â† è¿”å›ä¸»é¡µé¢</a>
        </div>

        <h1>ğŸ”§ Voice Communication è°ƒè¯•é¢æ¿</h1>

        <!-- çŠ¶æ€æ  -->
        <div class="status-bar">
            <div class="status-item">
                <div class="dot" id="connDot"></div>
                <span>è¿æ¥: <span id="connStatus">æœªè¿æ¥</span></span>
            </div>
            <div class="status-item">
                <div class="dot" id="micDot"></div>
                <span>éº¦å…‹é£: <span id="micStatus">å…³é—­</span></span>
            </div>
            <div class="status-item">
                <span>å®¢æˆ·ç«¯ID: <span id="clientId">-</span></span>
            </div>
        </div>

        <div class="grid">
            <!-- å·¦ä¾§é¢æ¿ -->
            <div>
                <!-- éŸ³é¢‘æ§åˆ¶ -->
                <div class="panel">
                    <h2>ğŸ¤ éŸ³é¢‘æ§åˆ¶</h2>
                    
                    <div class="btn-group" style="margin-bottom: 15px;">
                        <button id="btnStartAudio" style="background: #00ff00; color: #000; font-weight: bold;">ğŸ”Š å¼€å§‹æ¥æ”¶éŸ³é¢‘</button>
                        <button id="btnMic">å¼€å¯éº¦å…‹é£</button>
                        <button id="btnStopMic" class="danger">å…³é—­éº¦å…‹é£</button>
                    </div>

                    <div class="meter">
                        <label>éº¦å…‹é£éŸ³é‡:</label>
                        <div class="meter-bar">
                            <div class="meter-fill" id="micMeter" style="width: 0%"></div>
                        </div>
                        <span class="meter-value" id="micValue">0%</span>
                    </div>

                    <div class="meter" style="margin-top: 10px;">
                        <label>æ¥æ”¶éŸ³é‡:</label>
                        <div class="meter-bar">
                            <div class="meter-fill" id="spkMeter" style="width: 0%"></div>
                        </div>
                        <span class="meter-value" id="spkValue">0%</span>
                    </div>
                </div>

                <!-- å‚æ•°è°ƒæ•´ -->
                <div class="panel">
                    <h2>âš™ï¸ å‚æ•°è°ƒæ•´</h2>
                    
                    <div class="control-row">
                        <label>å™ªå£°é—¨é™:</label>
                        <input type="range" id="noiseThreshold" min="0" max="20" value="2">
                        <span id="noiseThresholdValue">2</span>
                    </div>

                    <div class="control-row">
                        <label>è¯´è¯æ£€æµ‹é—¨é™:</label>
                        <input type="range" id="speakingThreshold" min="5" max="50" value="15">
                        <span id="speakingThresholdValue">15</span>
                    </div>

                    <div class="control-row">
                        <label>æ’­æ”¾å»¶è¿Ÿ (ms):</label>
                        <input type="range" id="playbackLatency" min="10" max="200" value="50">
                        <span id="playbackLatencyValue">50</span>
                    </div>

                    <div class="control-row">
                        <label>å™ªå£°é—¨é™å¯ç”¨:</label>
                        <input type="checkbox" id="noiseGateEnabled" checked>
                    </div>

                    <div class="control-row">
                        <label>å¯¹è®²æ¨¡å¼ (PTT):</label>
                        <input type="checkbox" id="pttMode">
                    </div>
                </div>

                <!-- å¿«æ·å‘½ä»¤ -->
                <div class="panel">
                    <h2>âš¡ å¿«æ·å‘½ä»¤</h2>
                    <div class="btn-group">
                        <button class="quick-cmd" onclick="runCmd('client.pttMode = true')">å¼€å¯PTT</button>
                        <button class="quick-cmd" onclick="runCmd('client.pttMode = false')">å…³é—­PTT</button>
                        <button class="quick-cmd" onclick="runCmd('client.noiseGateEnabled = false')">å…³é—­å™ªå£°é—¨</button>
                        <button class="quick-cmd" onclick="runCmd('client.playbackLatency = 0.1')">å¢åŠ å»¶è¿Ÿ</button>
                        <button class="quick-cmd" onclick="runCmd('console.log(client)')">æ‰“å°å®¢æˆ·ç«¯</button>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§é¢æ¿ -->
            <div>
                <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                <div class="panel">
                    <h2>ğŸ“Š ç»Ÿè®¡ä¿¡æ¯</h2>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">å‘é€åŒ…æ•°</div>
                            <div class="stat-value" id="statSent">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">æ¥æ”¶åŒ…æ•°</div>
                            <div class="stat-value" id="statRecv">0</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">é‡‡æ ·ç‡</div>
                            <div class="stat-value" id="statSampleRate">-</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">å£°é“æ•°</div>
                            <div class="stat-value" id="statChannels">-</div>
                        </div>
                    </div>
                </div>

                <!-- æ—¥å¿— -->
                <div class="panel">
                    <h2>ğŸ“ æ—¥å¿—</h2>
                    <div class="btn-group" style="margin-bottom: 10px;">
                        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
                        <button onclick="toggleAutoScroll()">è‡ªåŠ¨æ»šåŠ¨: <span id="autoScrollStatus">å¼€</span></button>
                    </div>
                    <div class="log-container" id="logContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // è°ƒè¯•å®¢æˆ·ç«¯
        let client = null;
        let stats = { sent: 0, recv: 0 };
        let autoScroll = true;

        // æ—¥å¿—åŠŸèƒ½
        function log(msg, type = 'info') {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString();
            entry.textContent = `[${time}] ${msg}`;
            container.appendChild(entry);
            if (autoScroll) {
                container.scrollTop = container.scrollHeight;
            }
        }

        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }

        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            document.getElementById('autoScrollStatus').textContent = autoScroll ? 'å¼€' : 'å…³';
        }

        function runCmd(cmd) {
            try {
                eval(cmd);
                log(`æ‰§è¡Œ: ${cmd}`, 'info');
            } catch (e) {
                log(`é”™è¯¯: ${e.message}`, 'error');
            }
        }

        // ç®€åŒ–ç‰ˆå®¢æˆ·ç«¯
        class DebugVoiceClient {
            constructor() {
                this.socket = null;
                this.clientId = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.mediaStreamSource = null;
                this.scriptProcessor = null;
                this.playbackGain = null;
                
                this.isConnected = false;
                this.isMicActive = false;
                
                this.sampleRate = 48000;
                this.channels = 2;
                this.bufferSize = 2048;
                
                this.noiseGateEnabled = true;
                this.noiseThreshold = 2;
                this.speakingThreshold = 15;
                this.pttMode = false;
                this.isSpeaking = false;
                this.speakingTimeout = null;
                this.playbackVolume = 1.0;
                this.pttPlaybackVolume = 0.0;
                
                this.nextPlayTime = 0;
                this.playbackLatency = 0.05;
                
                this.initSocket();
            }

            initSocket() {
                this.socket = io({ transports: ['websocket', 'polling'] });
                
                this.socket.on('connect', () => {
                    log('WebSocket å·²è¿æ¥', 'info');
                });

                this.socket.on('connected', (data) => {
                    this.clientId = data.client_id;
                    this.isConnected = true;
                    updateUI();
                    log(`å®¢æˆ·ç«¯ID: ${this.clientId}`, 'info');
                });

                this.socket.on('disconnect', () => {
                    this.isConnected = false;
                    updateUI();
                    log('WebSocket æ–­å¼€', 'warn');
                });

                this.socket.on('audio_from_clubdeck', (data) => {
                    this.handleIncomingAudio(data);
                });

                this.socket.on('connect_error', (error) => {
                    log(`è¿æ¥é”™è¯¯: ${error}`, 'error');
                });
            }

            // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ - éœ€è¦ç”¨æˆ·äº¤äº’æ‰èƒ½æ’­æ”¾å£°éŸ³
            initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate
                    });
                }
                
                // ç¡®ä¿ AudioContext å¤„äºè¿è¡ŒçŠ¶æ€
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                // åˆ›å»ºæ’­æ”¾å¢ç›ŠèŠ‚ç‚¹
                if (!this.playbackGain) {
                    this.playbackGain = this.audioContext.createGain();
                    this.playbackGain.connect(this.audioContext.destination);
                }
                
                this.audioReady = true;
                log('âœ“ éŸ³é¢‘å·²æ¿€æ´»ï¼Œå¯ä»¥æ¥æ”¶ Clubdeck å£°éŸ³', 'info');
            }

            async startMic() {
                try {
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: this.sampleRate,
                            channelCount: this.channels
                        }
                    });

                    // å¦‚æœè¿˜æ²¡æœ‰åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼Œå…ˆåˆå§‹åŒ–
                    this.initAudioContext();

                    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.mediaStream);
                    this.scriptProcessor = this.audioContext.createScriptProcessor(this.bufferSize, this.channels, this.channels);

                    this.scriptProcessor.onaudioprocess = (event) => {
                        if (!this.isMicActive) return;

                        const leftChannel = event.inputBuffer.getChannelData(0);
                        const rightChannel = this.channels > 1 && event.inputBuffer.numberOfChannels > 1 
                            ? event.inputBuffer.getChannelData(1) 
                            : leftChannel;
                        
                        const volume = this.calculateVolume(leftChannel);
                        updateMicMeter(volume);
                        
                        if (this.noiseGateEnabled && volume < this.noiseThreshold) {
                            return;
                        }
                        
                        if (this.pttMode && volume >= this.speakingThreshold) {
                            this.setSpeaking(true);
                        }

                        const int16Data = this.float32StereoToInt16(leftChannel, rightChannel);
                        const base64Data = this.arrayBufferToBase64(int16Data.buffer);

                        this.socket.emit('audio_data', { audio: base64Data, channels: this.channels });
                        stats.sent++;
                    };

                    this.mediaStreamSource.connect(this.scriptProcessor);
                    this.scriptProcessor.connect(this.audioContext.destination);

                    this.isMicActive = true;
                    updateUI();
                    log('éº¦å…‹é£å·²å¼€å¯', 'info');

                } catch (error) {
                    log(`éº¦å…‹é£é”™è¯¯: ${error.message}`, 'error');
                }
            }

            stopMic() {
                if (this.scriptProcessor) {
                    this.scriptProcessor.disconnect();
                    this.scriptProcessor = null;
                }
                if (this.mediaStreamSource) {
                    this.mediaStreamSource.disconnect();
                    this.mediaStreamSource = null;
                }
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                this.isMicActive = false;
                this.setSpeaking(false);
                updateUI();
                log('éº¦å…‹é£å·²å…³é—­', 'info');
            }

            handleIncomingAudio(data) {
                // å¦‚æœéŸ³é¢‘æœªæ¿€æ´»ï¼Œè·³è¿‡æ’­æ”¾ä½†ä»æ˜¾ç¤ºéŸ³é‡
                if (!this.audioReady) {
                    try {
                        const int16Data = this.base64ToInt16Array(data.audio);
                        const channels = data.channels || this.channels;
                        const { left } = this.int16StereoToFloat32(int16Data, channels);
                        const volume = this.calculateVolume(left);
                        updateSpkMeter(volume);
                        stats.recv++;
                    } catch (e) {}
                    return;
                }

                try {
                    const int16Data = this.base64ToInt16Array(data.audio);
                    const channels = data.channels || this.channels;
                    const { left, right } = this.int16StereoToFloat32(int16Data, channels);

                    const volume = this.calculateVolume(left);
                    updateSpkMeter(volume);
                    stats.recv++;

                    this.playAudioStereo(left, right);
                    
                    // æ¯100åŒ…è®°å½•ä¸€æ¬¡
                    if (stats.recv % 100 === 0) {
                        log(`æ¥æ”¶éŸ³é¢‘ #${stats.recv}, éŸ³é‡: ${volume.toFixed(1)}%`, 'audio');
                    }

                } catch (error) {
                    log(`éŸ³é¢‘å¤„ç†é”™è¯¯: ${error.message}`, 'error');
                }
            }

            playAudioStereo(leftData, rightData) {
                if (!this.audioContext) return;

                const buffer = this.audioContext.createBuffer(2, leftData.length, this.audioContext.sampleRate);
                buffer.getChannelData(0).set(leftData);
                buffer.getChannelData(1).set(rightData);

                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                
                if (!this.playbackGain) {
                    this.playbackGain = this.audioContext.createGain();
                    this.playbackGain.connect(this.audioContext.destination);
                }
                
                source.connect(this.playbackGain);
                
                const currentTime = this.audioContext.currentTime;
                if (this.nextPlayTime < currentTime) {
                    this.nextPlayTime = currentTime + this.playbackLatency;
                }
                
                source.start(this.nextPlayTime);
                this.nextPlayTime += buffer.duration;
            }

            setSpeaking(speaking) {
                if (!this.pttMode || !this.playbackGain) return;
                
                if (speaking) {
                    if (!this.isSpeaking) {
                        this.isSpeaking = true;
                        this.playbackGain.gain.setTargetAtTime(this.pttPlaybackVolume, this.audioContext.currentTime, 0.05);
                        log('PTT: é™ä½æ¥æ”¶éŸ³é‡', 'audio');
                    }
                    if (this.speakingTimeout) clearTimeout(this.speakingTimeout);
                    this.speakingTimeout = setTimeout(() => this.setSpeaking(false), 300);
                } else {
                    if (this.isSpeaking) {
                        this.isSpeaking = false;
                        if (this.speakingTimeout) {
                            clearTimeout(this.speakingTimeout);
                            this.speakingTimeout = null;
                        }
                        this.playbackGain.gain.setTargetAtTime(this.playbackVolume, this.audioContext.currentTime, 0.1);
                        log('PTT: æ¢å¤æ¥æ”¶éŸ³é‡', 'audio');
                    }
                }
            }

            calculateVolume(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += Math.abs(data[i]);
                }
                return (sum / data.length) * 100 * 10;
            }

            float32StereoToInt16(left, right) {
                const length = left.length;
                const int16 = new Int16Array(length * 2);
                for (let i = 0; i < length; i++) {
                    int16[i * 2] = Math.max(-32768, Math.min(32767, Math.round(left[i] * 32767)));
                    int16[i * 2 + 1] = Math.max(-32768, Math.min(32767, Math.round(right[i] * 32767)));
                }
                return int16;
            }

            int16StereoToFloat32(int16Data, channels) {
                if (channels === 2) {
                    const length = int16Data.length / 2;
                    const left = new Float32Array(length);
                    const right = new Float32Array(length);
                    for (let i = 0; i < length; i++) {
                        left[i] = int16Data[i * 2] / 32768;
                        right[i] = int16Data[i * 2 + 1] / 32768;
                    }
                    return { left, right };
                } else {
                    const mono = new Float32Array(int16Data.length);
                    for (let i = 0; i < int16Data.length; i++) {
                        mono[i] = int16Data[i] / 32768;
                    }
                    return { left: mono, right: mono };
                }
            }

            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            base64ToInt16Array(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return new Int16Array(bytes.buffer);
            }
        }

        // UI æ›´æ–°
        function updateUI() {
            document.getElementById('connDot').className = 'dot' + (client?.isConnected ? ' connected' : '');
            document.getElementById('connStatus').textContent = client?.isConnected ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
            document.getElementById('micDot').className = 'dot' + (client?.isMicActive ? ' active' : '');
            document.getElementById('micStatus').textContent = client?.isMicActive ? 'å¼€å¯' : 'å…³é—­';
            document.getElementById('clientId').textContent = client?.clientId || '-';
            document.getElementById('statSampleRate').textContent = client?.sampleRate || '-';
            document.getElementById('statChannels').textContent = client?.channels || '-';
        }

        function updateMicMeter(volume) {
            document.getElementById('micMeter').style.width = Math.min(100, volume) + '%';
            document.getElementById('micValue').textContent = volume.toFixed(0) + '%';
        }

        function updateSpkMeter(volume) {
            document.getElementById('spkMeter').style.width = Math.min(100, volume) + '%';
            document.getElementById('spkValue').textContent = volume.toFixed(0) + '%';
        }

        // ç»Ÿè®¡æ›´æ–°
        setInterval(() => {
            document.getElementById('statSent').textContent = stats.sent;
            document.getElementById('statRecv').textContent = stats.recv;
        }, 500);

        // å‚æ•°ç»‘å®š
        document.getElementById('noiseThreshold').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('noiseThresholdValue').textContent = val;
            if (client) client.noiseThreshold = val;
        });

        document.getElementById('speakingThreshold').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('speakingThresholdValue').textContent = val;
            if (client) client.speakingThreshold = val;
        });

        document.getElementById('playbackLatency').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('playbackLatencyValue').textContent = val;
            if (client) client.playbackLatency = val / 1000;
        });

        document.getElementById('noiseGateEnabled').addEventListener('change', (e) => {
            if (client) client.noiseGateEnabled = e.target.checked;
            log(`å™ªå£°é—¨é™: ${e.target.checked ? 'å¼€' : 'å…³'}`, 'info');
        });

        document.getElementById('pttMode').addEventListener('change', (e) => {
            if (client) client.pttMode = e.target.checked;
            log(`å¯¹è®²æ¨¡å¼: ${e.target.checked ? 'å¼€' : 'å…³'}`, 'info');
        });

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('btnStartAudio').addEventListener('click', () => {
            if (client) {
                client.initAudioContext();
                document.getElementById('btnStartAudio').textContent = 'âœ“ å·²å¼€å§‹æ¥æ”¶';
                document.getElementById('btnStartAudio').disabled = true;
                document.getElementById('btnStartAudio').style.opacity = '0.5';
            }
        });

        document.getElementById('btnMic').addEventListener('click', () => {
            if (client) client.startMic();
        });

        document.getElementById('btnStopMic').addEventListener('click', () => {
            if (client) client.stopMic();
        });

        // åˆå§‹åŒ–
        window.onload = () => {
            log('è°ƒè¯•é¢æ¿å·²åŠ è½½', 'info');
            log('âš ï¸ è¯·ç‚¹å‡»"å¼€å§‹æ¥æ”¶éŸ³é¢‘"æŒ‰é’®ä»¥æ¿€æ´»éŸ³é¢‘æ’­æ”¾', 'warn');
            client = new DebugVoiceClient();
            window.client = client; // æš´éœ²åˆ°å…¨å±€
            updateUI();
        };
    </script>
</body>
</html>
