<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Club Voice - å®æ—¶è¯­éŸ³é€šä¿¡</title>
    
    <!-- PWA Manifest - iOS Safari éœ€è¦æ ¹è·¯å¾„ -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/icon-96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/icon-72.png">
    
    <!-- iOS ç‰¹å®š Meta æ ‡ç­¾ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ClubVoice">
    <link rel="apple-touch-icon" href="/static/icon-152.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/static/icon-72.png">
    <link rel="apple-touch-icon" sizes="96x96" href="/static/icon-96.png">
    <link rel="apple-touch-icon" sizes="128x128" href="/static/icon-128.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/static/icon-144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/static/icon-152.png">
    <link rel="apple-touch-icon" sizes="192x192" href="/static/icon-192.png">
    <link rel="apple-touch-icon" sizes="384x384" href="/static/icon-384.png">
    <link rel="apple-touch-icon" sizes="512x512" href="/static/icon-512.png">
    
    <!-- Android / Chrome -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#16213e">
    <meta name="application-name" content="ClubVoice">
    
    <!-- Windows -->
    <meta name="msapplication-TileColor" content="#16213e">
    <meta name="msapplication-TileImage" content="/static/icon-144.png">
    <meta name="msapplication-config" content="none">
    
    <!-- æè¿°å’Œå…³é”®è¯ -->
    <meta name="description" content="æµè§ˆå™¨ä¸ Clubdeck å®æ—¶è¯­éŸ³é€šä¿¡æ¡¥æ¥ï¼Œæ”¯æŒåå°æ’­æ”¾">
    <meta name="keywords" content="ClubVoice,è¯­éŸ³é€šä¿¡,å®æ—¶éŸ³é¢‘,Clubdeck,WebRTC">
    <meta name="author" content="ClubVoice Team">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.9rem;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            transition: background 0.3s;
        }

        .status-dot.connected {
            background: #44ff44;
            box-shadow: 0 0 10px #44ff44;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mic-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            color: white;
            font-size: 2.5rem;
            cursor: pointer;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .mic-button:hover {
            transform: scale(1.05);
        }

        .mic-button.active {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(46, 204, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 20px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        .volume-container {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .volume-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .volume-meter {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .volume-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.05s;
            border-radius: 4px;
        }

        .info-text {
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            margin-top: 20px;
        }

        .listen-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .listen-button:hover {
            transform: scale(1.02);
        }

        .listen-button.active {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .listen-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }
        
        .mode-indicator {
            text-align: center;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }
        
        .mode-half {
            background: rgba(241, 196, 15, 0.2);
            border: 1px solid #f1c40f;
            color: #f1c40f;
        }
        
        .mode-full {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
        }

        .hidden {
            display: none !important;
        }

        .nav-link {
            text-align: center;
            margin-top: 20px;
        }

        .nav-link a {
            color: #3498db;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav-link a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ™ï¸ Club Voice</h1>
        <p class="subtitle">æµè§ˆå™¨ â†” Club House å®æ—¶è¯­éŸ³é€šä¿¡</p>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">æœªè¿æ¥</span>
            </div>
            <span id="clientId"></span>
        </div>
        
         <div class="controls">
            <button class="listen-button" id="listenButton">
                ğŸ”Š å¼€å§‹æ”¶å¬ Clubdeck
            </button>

            <button class="mic-button" id="micButton" title="ç‚¹å‡»å¼€å§‹/åœæ­¢é€šè¯">
                ğŸ¤
            </button>

            <div class="volume-container">
                <div class="volume-label">
                    <span>ğŸ¤ éº¦å…‹é£éŸ³é‡</span>
                    <span id="micLevel">0%</span>
                </div>
                <div class="volume-meter">
                    <div class="volume-bar" id="micVolumeBar"></div>
                </div>
            </div>

            <div class="volume-container">
                <div class="volume-label">
                    <span>ğŸ”Š æ¥æ”¶éŸ³é‡</span>
                    <span id="speakerLevel">0%</span>
                </div>
                <div class="volume-meter">
                    <div class="volume-bar" id="speakerVolumeBar"></div>
                </div>
            </div>
        </div>

        <p class="info-text">ç‚¹å‡»ã€Œå¼€å§‹æ”¶å¬ã€æ”¶å¬ æˆ¿é—´ï¼Œç‚¹å‡»éº¦å…‹é£å‘è¨€</p>

        <div class="error-message" id="errorMessage"></div>

        <div class="nav-link">
            <a href="/static/debug.html">ğŸ”§ è°ƒè¯•é¢æ¿</a>
            <span style="margin: 0 10px;">|</span>
            <a href="/static/pwa-test.html">ğŸ“± PWA æµ‹è¯•</a>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        class VoiceClient {
            constructor() {
                this.socket = null;
                this.clientId = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.mediaStreamSource = null;
                this.scriptProcessor = null;
                this.playbackGain = null;
                
                this.isConnected = false;
                this.isMicActive = false;
                this.audioReady = false;
                
                this.sampleRate = 48000;
                this.channels = 2;
                this.bufferSize = 2048;
                
                this.noiseGateEnabled = true;
                this.noiseThreshold = 2;
                
                this.nextPlayTime = 0;
                this.playbackLatency = 0.05;
                
                // åŒå·¥æ¨¡å¼
                this.duplexMode = 'half';
                
                // iOS åå°æ’­æ”¾æ”¯æŒ
                this.keepAliveAudio = null;
                this.silenceBuffer = null;
                this.setupMediaSession();
                this.setupVisibilityHandling();
                this.setupKeepAliveAudio();
                
                this.initSocket();
            }

            // åˆ›å»ºä¿æŒåå°æ´»è·ƒçš„éšè—éŸ³é¢‘å…ƒç´ 
            setupKeepAliveAudio() {
                // åˆ›å»ºä¸€ä¸ªéå¸¸å°çš„é™éŸ³ WAV æ•°æ® (1ç§’ @ 8000Hz mono)
                const sampleRate = 8000;
                const duration = 1;
                const numSamples = sampleRate * duration;
                const buffer = new ArrayBuffer(44 + numSamples * 2);
                const view = new DataView(buffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + numSamples * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true); // chunk size
                view.setUint16(20, 1, true); // PCM
                view.setUint16(22, 1, true); // mono
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true); // byte rate
                view.setUint16(32, 2, true); // block align
                view.setUint16(34, 16, true); // bits per sample
                writeString(36, 'data');
                view.setUint32(40, numSamples * 2, true);
                
                // å†™å…¥é™éŸ³æ•°æ® (å…¨0)
                for (let i = 0; i < numSamples; i++) {
                    view.setInt16(44 + i * 2, 0, true);
                }
                
                // åˆ›å»º Blob å’Œ URL
                const blob = new Blob([buffer], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                // åˆ›å»ºéšè—çš„ audio å…ƒç´ 
                this.keepAliveAudio = document.createElement('audio');
                this.keepAliveAudio.src = url;
                this.keepAliveAudio.loop = true;
                this.keepAliveAudio.volume = 0.01; // å‡ ä¹é™éŸ³ä½†ä¸ä¸º0
                this.keepAliveAudio.playsInline = true;
                this.keepAliveAudio.setAttribute('playsinline', '');
                this.keepAliveAudio.setAttribute('webkit-playsinline', '');
                
                // iOS éœ€è¦è¿™äº›å±æ€§
                this.keepAliveAudio.muted = false;
                this.keepAliveAudio.preload = 'auto';
                
                console.log('âœ“ Keep-alive éŸ³é¢‘å·²åˆ›å»º');
            }

            // å¯åŠ¨ä¿æŒåå°æ´»è·ƒçš„éŸ³é¢‘
            startKeepAlive() {
                if (!this.keepAliveAudio) return;
                
                const playPromise = this.keepAliveAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('âœ“ Keep-alive éŸ³é¢‘å·²å¯åŠ¨');
                    }).catch(err => {
                        console.log('Keep-alive éŸ³é¢‘å¯åŠ¨å¤±è´¥:', err);
                    });
                }
            }

            // åœæ­¢ä¿æŒåå°æ´»è·ƒçš„éŸ³é¢‘
            stopKeepAlive() {
                if (this.keepAliveAudio) {
                    this.keepAliveAudio.pause();
                    console.log('Keep-alive éŸ³é¢‘å·²åœæ­¢');
                }
            }

            setupMediaSession() {
                if ('mediaSession' in navigator) {
                    // è®¾ç½®åª’ä½“å…ƒæ•°æ®
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: 'ClubVoice è¯­éŸ³é€šä¿¡',
                        artist: 'Clubdeck Room',
                        album: 'å®æ—¶è¯­éŸ³'
                    });

                    // æ’­æ”¾æ§åˆ¶
                    navigator.mediaSession.setActionHandler('play', () => {
                        console.log('MediaSession: æ’­æ”¾');
                        if (this.audioContext && this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    });

                    navigator.mediaSession.setActionHandler('pause', () => {
                        console.log('MediaSession: æš‚åœ');
                        if (this.audioContext && this.audioContext.state === 'running') {
                            this.audioContext.suspend();
                        }
                    });

                    console.log('âœ“ MediaSession API å·²å¯ç”¨');
                }
            }

            setupVisibilityHandling() {
                // ç›‘å¬é¡µé¢å¯è§æ€§å˜åŒ–
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        console.log('é¡µé¢è¿›å…¥åå°');
                        this.handleBackgroundMode();
                    } else {
                        console.log('é¡µé¢å›åˆ°å‰å°');
                        this.handleForegroundMode();
                    }
                });
            }

            handleBackgroundMode() {
                // åå°æ¨¡å¼å¤„ç† - iOS Safari ç‰¹æ®Šå¤„ç†
                console.log('åå°æ¨¡å¼: AudioContext çŠ¶æ€:', this.audioContext?.state);
                
                // ç¡®ä¿ keep-alive éŸ³é¢‘åœ¨æ’­æ”¾
                if (this.keepAliveAudio && this.keepAliveAudio.paused && this.audioReady) {
                    this.startKeepAlive();
                }
                
                // å°è¯•ä¿æŒ AudioContext è¿è¡Œ
                if (this.audioContext && this.audioContext.state === 'suspended' && this.audioReady) {
                    this.attemptResumeAudio();
                }
                
                // æ›´æ–° MediaSession çŠ¶æ€ä¸ºæ’­æ”¾ä¸­
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'playing';
                }
                
                // iOS: å®šæœŸå°è¯•æ¢å¤éŸ³é¢‘
                if (this.audioReady && !this.backgroundInterval) {
                    this.backgroundInterval = setInterval(() => {
                        if (document.hidden && this.audioContext) {
                            if (this.audioContext.state === 'suspended' || this.audioContext.state === 'interrupted') {
                                console.log('åå°: å°è¯•æ¢å¤ AudioContext...');
                                this.audioContext.resume().catch(e => {
                                    console.log('åå°æ¢å¤å¤±è´¥:', e);
                                });
                            }
                        }
                    }, 3000); // æ¯3ç§’å°è¯•ä¸€æ¬¡
                }
            }

            handleForegroundMode() {
                // å‰å°æ¨¡å¼å¤„ç†
                console.log('å‰å°æ¨¡å¼: AudioContext çŠ¶æ€:', this.audioContext?.state);
                
                // æ¸…ç†åå°å®šæ—¶å™¨
                if (this.backgroundInterval) {
                    clearInterval(this.backgroundInterval);
                    this.backgroundInterval = null;
                }
                
                // æ¢å¤ AudioContext
                if (this.audioContext && this.audioContext.state === 'suspended' && this.audioReady) {
                    this.audioContext.resume().then(() => {
                        console.log('âœ“ å‰å°æ¢å¤ AudioContext æˆåŠŸ');
                    }).catch(e => {
                        console.log('å‰å°æ¢å¤å¤±è´¥:', e);
                    });
                }
            }

            attemptResumeAudio() {
                if (!this.audioContext || !this.audioReady) return;
                
                const resumeAttempt = () => {
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume().then(() => {
                            console.log('âœ“ AudioContext å·²æ¢å¤');
                        }).catch(err => {
                            console.log('æ¢å¤å¤±è´¥ï¼Œ1ç§’åé‡è¯•:', err);
                            setTimeout(resumeAttempt, 1000);
                        });
                    }
                };
                
                resumeAttempt();
            }

            initSocket() {
                this.socket = io({ transports: ['websocket', 'polling'] });
                
                this.socket.on('connect', () => {
                    console.log('WebSocket å·²è¿æ¥');
                });

                this.socket.on('connected', (data) => {
                    this.clientId = data.client_id;
                    this.isConnected = true;
                    
                    // è·å–åŒå·¥æ¨¡å¼
                    if (data.duplex_mode) {
                        this.duplexMode = data.duplex_mode;
                        this.updateDuplexUI();
                    }
                    
                    this.updateUI();
                    console.log('å®¢æˆ·ç«¯ID:', this.clientId, 'åŒå·¥æ¨¡å¼:', this.duplexMode);
                });

                this.socket.on('disconnect', () => {
                    this.isConnected = false;
                    this.updateUI();
                    console.log('WebSocket æ–­å¼€');
                });

                this.socket.on('audio_from_clubdeck', (data) => {
                    this.handleIncomingAudio(data);
                });

                this.socket.on('connect_error', (error) => {
                    console.error('è¿æ¥é”™è¯¯:', error);
                });
            }

            updateUI() {
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const clientIdEl = document.getElementById('clientId');
                const micButton = document.getElementById('micButton');
                
                if (statusDot) {
                    statusDot.className = 'status-dot' + (this.isConnected ? ' connected' : '');
                }
                if (statusText) {
                    statusText.textContent = this.isConnected ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
                }
                if (clientIdEl) {
                    clientIdEl.textContent = this.clientId ? `ID: ${this.clientId.slice(0, 8)}...` : '';
                }
                
                // æ›´æ–°éº¦å…‹é£æŒ‰é’®çŠ¶æ€
                if (micButton) {
                    micButton.className = 'mic-button' + (this.isMicActive ? ' active' : '');
                }
            }

            updateDuplexUI() {
                const modeIndicator = document.getElementById('modeIndicator');
                const micButton = document.getElementById('micButton');
                
                if (this.duplexMode === 'half') {
                    if (modeIndicator) {
                        modeIndicator.textContent = 'ğŸ“» åŠåŒå·¥ (ä»…ç›‘å¬)';
                        modeIndicator.className = 'mode-indicator mode-half';
                    }
                    if (micButton) {
                        micButton.classList.add('hidden');
                    }
                } else {
                    if (modeIndicator) {
                        modeIndicator.textContent = 'ğŸ“ å…¨åŒå·¥ (åŒå‘é€šä¿¡)';
                        modeIndicator.className = 'mode-indicator mode-full';
                    }
                    if (micButton) {
                        micButton.classList.remove('hidden');
                    }
                }
            }

            initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate,
                        latencyHint: 'interactive' // iOS ä¼˜åŒ–
                    });
                    
                    // æ·»åŠ çŠ¶æ€ç›‘å¬
                    this.audioContext.addEventListener('statechange', () => {
                        console.log('AudioContext çŠ¶æ€:', this.audioContext.state);
                        if (this.audioContext.state === 'interrupted') {
                            // iOS ç‰¹æœ‰ï¼šéŸ³é¢‘è¢«ä¸­æ–­
                            console.log('éŸ³é¢‘è¢«ä¸­æ–­ï¼Œå°è¯•æ¢å¤...');
                            this.attemptResumeAudio();
                        }
                    });
                    
                    // iOS: å°† keep-alive audio è¿æ¥åˆ° AudioContext
                    if (this.keepAliveAudio) {
                        try {
                            this.keepAliveSource = this.audioContext.createMediaElementSource(this.keepAliveAudio);
                            // è¿æ¥ä½†éŸ³é‡å¾ˆå°
                            const keepAliveGain = this.audioContext.createGain();
                            keepAliveGain.gain.value = 0.001; // å‡ ä¹é™éŸ³
                            this.keepAliveSource.connect(keepAliveGain);
                            keepAliveGain.connect(this.audioContext.destination);
                            console.log('âœ“ Keep-alive å·²è¿æ¥åˆ° AudioContext');
                        } catch (e) {
                            console.log('Keep-alive è¿æ¥å¤±è´¥:', e);
                        }
                    }
                }
                
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                if (!this.playbackGain) {
                    this.playbackGain = this.audioContext.createGain();
                    this.playbackGain.connect(this.audioContext.destination);
                }
                
                this.audioReady = true;
                
                // å¯åŠ¨ keep-alive éŸ³é¢‘ (iOS åå°ä¿æŒ)
                this.startKeepAlive();
                
                // æ›´æ–° MediaSession çŠ¶æ€
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.playbackState = 'playing';
                }
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const btn = document.getElementById('listenButton');
                if (btn) {
                    btn.textContent = 'âœ… æ­£åœ¨æ”¶å¬ Clubdeck';
                    btn.classList.add('active');
                }
                
                console.log('âœ“ éŸ³é¢‘å·²æ¿€æ´» (iOS åå°æ”¯æŒ)');
            }

            async toggleMic() {
                if (this.isMicActive) {
                    this.stopMic();
                } else {
                    await this.startMic();
                }
            }

            async startMic() {
                if (this.duplexMode === 'half') {
                    console.log('åŠåŒå·¥æ¨¡å¼ï¼Œéº¦å…‹é£å·²ç¦ç”¨');
                    return;
                }
                
                try {
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: this.sampleRate,
                            channelCount: this.channels
                        }
                    });

                    this.initAudioContext();

                    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.mediaStream);
                    this.scriptProcessor = this.audioContext.createScriptProcessor(this.bufferSize, this.channels, this.channels);

                    this.scriptProcessor.onaudioprocess = (event) => {
                        if (!this.isMicActive) return;

                        const leftChannel = event.inputBuffer.getChannelData(0);
                        const rightChannel = this.channels > 1 && event.inputBuffer.numberOfChannels > 1 
                            ? event.inputBuffer.getChannelData(1) 
                            : leftChannel;
                        
                        const volume = this.calculateVolume(leftChannel);
                        this.updateMicMeter(volume);
                        
                        if (this.noiseGateEnabled && volume < this.noiseThreshold) {
                            return;
                        }

                        const int16Data = this.float32StereoToInt16(leftChannel, rightChannel);
                        const base64Data = this.arrayBufferToBase64(int16Data.buffer);

                        this.socket.emit('audio_data', { audio: base64Data, channels: this.channels });
                    };

                    this.mediaStreamSource.connect(this.scriptProcessor);
                    this.scriptProcessor.connect(this.audioContext.destination);

                    this.isMicActive = true;
                    this.updateUI();
                    console.log('éº¦å…‹é£å·²å¼€å¯');

                } catch (error) {
                    console.error('éº¦å…‹é£é”™è¯¯:', error);
                }
            }

            stopMic() {
                if (this.scriptProcessor) {
                    this.scriptProcessor.disconnect();
                    this.scriptProcessor = null;
                }
                if (this.mediaStreamSource) {
                    this.mediaStreamSource.disconnect();
                    this.mediaStreamSource = null;
                }
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                this.isMicActive = false;
                this.updateUI();
                console.log('éº¦å…‹é£å·²å…³é—­');
            }

            handleIncomingAudio(data) {
                try {
                    const int16Data = this.base64ToInt16Array(data.audio);
                    const channels = data.channels || this.channels;
                    const { left, right } = this.int16StereoToFloat32(int16Data, channels);

                    const volume = this.calculateVolume(left);
                    this.updateSpkMeter(volume);

                    if (this.audioReady) {
                        this.playAudioStereo(left, right);
                        
                        // æ›´æ–° MediaSession çŠ¶æ€ï¼ˆè®© iOS çŸ¥é“éŸ³é¢‘åœ¨æ’­æ”¾ï¼‰
                        if ('mediaSession' in navigator && navigator.mediaSession.playbackState !== 'playing') {
                            navigator.mediaSession.playbackState = 'playing';
                        }
                    }

                } catch (error) {
                    console.error('éŸ³é¢‘å¤„ç†é”™è¯¯:', error);
                }
            }

            playAudioStereo(leftData, rightData) {
                if (!this.audioContext) return;

                const buffer = this.audioContext.createBuffer(2, leftData.length, this.audioContext.sampleRate);
                buffer.getChannelData(0).set(leftData);
                buffer.getChannelData(1).set(rightData);

                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(this.playbackGain);
                
                const currentTime = this.audioContext.currentTime;
                if (this.nextPlayTime < currentTime) {
                    this.nextPlayTime = currentTime + this.playbackLatency;
                }
                
                source.start(this.nextPlayTime);
                this.nextPlayTime += buffer.duration;
            }

            updateMicMeter(volume) {
                const bar = document.getElementById('micVolumeBar');
                const level = document.getElementById('micLevel');
                if (bar) bar.style.width = Math.min(100, volume) + '%';
                if (level) level.textContent = volume.toFixed(0) + '%';
            }

            updateSpkMeter(volume) {
                const bar = document.getElementById('speakerVolumeBar');
                const level = document.getElementById('speakerLevel');
                if (bar) bar.style.width = Math.min(100, volume) + '%';
                if (level) level.textContent = volume.toFixed(0) + '%';
            }

            calculateVolume(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += Math.abs(data[i]);
                }
                return (sum / data.length) * 100 * 10;
            }

            float32StereoToInt16(left, right) {
                const length = left.length;
                const int16 = new Int16Array(length * 2);
                for (let i = 0; i < length; i++) {
                    int16[i * 2] = Math.max(-32768, Math.min(32767, Math.round(left[i] * 32767)));
                    int16[i * 2 + 1] = Math.max(-32768, Math.min(32767, Math.round(right[i] * 32767)));
                }
                return int16;
            }

            int16StereoToFloat32(int16Data, channels) {
                if (channels === 2) {
                    const length = int16Data.length / 2;
                    const left = new Float32Array(length);
                    const right = new Float32Array(length);
                    for (let i = 0; i < length; i++) {
                        left[i] = int16Data[i * 2] / 32768;
                        right[i] = int16Data[i * 2 + 1] / 32768;
                    }
                    return { left, right };
                } else {
                    const mono = new Float32Array(int16Data.length);
                    for (let i = 0; i < int16Data.length; i++) {
                        mono[i] = int16Data[i] / 32768;
                    }
                    return { left: mono, right: mono };
                }
            }

            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            base64ToInt16Array(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return new Int16Array(bytes.buffer);
            }
        }

        // æ£€æµ‹ iOS Safari
        function isIOSSafari() {
            const ua = navigator.userAgent;
            const iOS = /iPad|iPhone|iPod/.test(ua);
            const webkit = /WebKit/.test(ua);
            const chrome = /CriOS|FxiOS|EdgiOS/.test(ua);
            return iOS && webkit && !chrome;
        }

        // æ˜¾ç¤º PWA å®‰è£…æç¤º
        function showPWAInstallPrompt() {
            const pwaHint = document.createElement('div');
            pwaHint.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(46, 204, 113, 0.95);
                color: #fff;
                padding: 12px 20px;
                border-radius: 10px;
                font-size: 0.85rem;
                z-index: 1001;
                max-width: 90%;
                text-align: center;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease-out;
                cursor: pointer;
            `;
            pwaHint.innerHTML = 'âœ¨ å°† ClubVoice æ·»åŠ åˆ°ä¸»å±å¹•ï¼Œè·å¾—æ›´å¥½ä½“éªŒ';
            document.body.appendChild(pwaHint);
            
            pwaHint.addEventListener('click', () => {
                pwaHint.remove();
            });
            
            // 8ç§’åæ·¡å‡º
            setTimeout(() => {
                pwaHint.style.transition = 'opacity 0.5s';
                pwaHint.style.opacity = '0';
                setTimeout(() => pwaHint.remove(), 500);
            }, 8000);
        }

        // æ³¨å†Œ Service Worker
        async function registerServiceWorker() {
            if (!('serviceWorker' in navigator)) {
                console.log('æµè§ˆå™¨ä¸æ”¯æŒ Service Worker');
                return null;
            }
            
            try {
                const registration = await navigator.serviceWorker.register('/static/sw.js', {
                    scope: '/'
                });
                
                console.log('âœ“ Service Worker å·²æ³¨å†Œ:', registration.scope);
                
                // ç›‘å¬æ›´æ–°
                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    console.log('å‘ç° Service Worker æ›´æ–°');
                    
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            console.log('æ–°ç‰ˆæœ¬å¯ç”¨ï¼Œåˆ·æ–°é¡µé¢ä»¥æ›´æ–°');
                            // å¯ä»¥æ˜¾ç¤ºæ›´æ–°æç¤º
                        }
                    });
                });
                
                // å®šæœŸå‘é€ keep-alive æ¶ˆæ¯
                setInterval(() => {
                    if (registration.active) {
                        const messageChannel = new MessageChannel();
                        messageChannel.port1.onmessage = (event) => {
                            if (event.data && event.data.type === 'PONG') {
                                console.log('[SW] Keep-alive pong æ”¶åˆ°');
                            }
                        };
                        
                        registration.active.postMessage(
                            { type: 'KEEP_ALIVE' },
                            [messageChannel.port2]
                        );
                    }
                }, 30000); // æ¯30ç§’
                
                return registration;
                
            } catch (error) {
                console.error('Service Worker æ³¨å†Œå¤±è´¥:', error);
                return null;
            }
        }

        // PWA å®‰è£…æç¤º
        let deferredPrompt = null;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('å¯ä»¥å®‰è£… PWA');
            e.preventDefault();
            deferredPrompt = e;
            
            // æ˜¾ç¤ºè‡ªå®šä¹‰å®‰è£…æç¤º
            setTimeout(() => {
                showPWAInstallPrompt();
            }, 3000);
        });

        window.addEventListener('appinstalled', () => {
            console.log('PWA å·²å®‰è£…');
            deferredPrompt = null;
        });

        // æ˜¾ç¤º iOS ä½¿ç”¨æç¤º
        function showIOSHint() {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ PWA æ¨¡å¼
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                                 window.navigator.standalone === true;
            
            const iosHint = document.createElement('div');
            iosHint.id = 'iosHint';
            iosHint.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(241, 196, 15, 0.95);
                color: #000;
                padding: 15px 20px;
                border-radius: 12px;
                font-size: 0.85rem;
                z-index: 1000;
                max-width: 90%;
                text-align: center;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                animation: slideUp 0.3s ease-out;
            `;
            
            if (isStandalone) {
                // å·²ç»æ˜¯ PWA æ¨¡å¼
                iosHint.innerHTML = `
                    <div style="font-size: 1.1rem; margin-bottom: 8px;">âœ… PWA æ¨¡å¼å·²æ¿€æ´»</div>
                    <div>åå°æ’­æ”¾å·²å¯ç”¨ï¼Œå¯ä»¥åˆ‡æ¢åº”ç”¨æˆ–é”å±</div>
                `;
                iosHint.style.background = 'rgba(46, 204, 113, 0.95)';
                iosHint.style.color = '#fff';
            } else {
                // è¿˜åœ¨æµè§ˆå™¨ä¸­
                iosHint.innerHTML = `
                    <div style="font-size: 1.1rem; margin-bottom: 8px;">ğŸ’¡ è·å¾—æ›´å¥½çš„åå°æ’­æ”¾ä½“éªŒ</div>
                    <div style="margin-bottom: 10px;">ç‚¹å‡» <strong>åˆ†äº«</strong> âœ <strong>æ·»åŠ åˆ°ä¸»å±å¹•</strong></div>
                    <div style="font-size: 0.75rem; opacity: 0.8;">ä½œä¸º App è¿è¡Œå¯è·å¾—æ›´ç¨³å®šçš„åå°æ’­æ”¾</div>
                `;
            }
            
            document.body.appendChild(iosHint);
            
            // ç‚¹å‡»å…³é—­
            iosHint.addEventListener('click', () => {
                iosHint.style.transition = 'opacity 0.3s';
                iosHint.style.opacity = '0';
                setTimeout(() => iosHint.remove(), 300);
            });
            
            // 8ç§’åæ·¡å‡º
            setTimeout(() => {
                if (document.getElementById('iosHint')) {
                    iosHint.style.transition = 'opacity 0.5s';
                    iosHint.style.opacity = '0';
                    setTimeout(() => iosHint.remove(), 500);
                }
            }, 8000);
        }

        // åˆå§‹åŒ–
        let client = null;
        
        window.onload = async () => {
            // æ³¨å†Œ Service Worker
            const swRegistration = await registerServiceWorker();
            
            client = new VoiceClient();
            window.client = client;
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('listenButton').addEventListener('click', () => {
                client.initAudioContext();
                
                // æ˜¾ç¤º iOS æç¤º
                if (isIOSSafari()) {
                    showIOSHint();
                }
            });
            
            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.addEventListener('click', () => {
                    client.toggleMic();
                });
            }
            
            // iOS ç¯å¢ƒæ˜¾ç¤ºåˆå§‹æç¤º
            if (isIOSSafari()) {
                console.log('æ£€æµ‹åˆ° iOS Safariï¼ŒMediaSession API å·²å¯ç”¨');
            }
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºç‹¬ç«‹æ¨¡å¼ï¼ˆPWA å·²å®‰è£…ï¼‰
            if (window.matchMedia('(display-mode: standalone)').matches) {
                console.log('âœ“ è¿è¡Œåœ¨ PWA ç‹¬ç«‹æ¨¡å¼');
            }
        };
    </script>
</body>
</html>
