<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Club Voice- å®æ—¶è¯­éŸ³é€šä¿¡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.9rem;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            transition: background 0.3s;
        }

        .status-dot.connected {
            background: #44ff44;
            box-shadow: 0 0 10px #44ff44;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mic-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            color: white;
            font-size: 2.5rem;
            cursor: pointer;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .mic-button:hover {
            transform: scale(1.05);
        }

        .mic-button.active {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(46, 204, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }

        .volume-container {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .volume-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        .volume-meter {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .volume-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            transition: width 0.05s;
            border-radius: 4px;
        }

        .info-text {
            text-align: center;
            color: #888;
            font-size: 0.85rem;
            margin-top: 20px;
        }

        .listen-button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .listen-button:hover {
            transform: scale(1.02);
        }

        .listen-button.active {
            background: linear-gradient(145deg, #27ae60, #2ecc71);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .listen-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .error-message {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }
        
        .mode-indicator {
            text-align: center;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            margin-bottom: 15px;
        }
        
        .mode-half {
            background: rgba(241, 196, 15, 0.2);
            border: 1px solid #f1c40f;
            color: #f1c40f;
        }
        
        .mode-full {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid #2ecc71;
            color: #2ecc71;
        }

        .hidden {
            display: none !important;
        }

        .nav-link {
            text-align: center;
            margin-top: 20px;
        }

        .nav-link a {
            color: #3498db;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav-link a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ™ï¸ Club Voice</h1>
        <p class="subtitle">æµè§ˆå™¨ â†” Club House å®æ—¶è¯­éŸ³é€šä¿¡</p>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">æœªè¿æ¥</span>
            </div>
            <span id="clientId"></span>
        </div>
        
         <div class="controls">
            <button class="listen-button" id="listenButton">
                ğŸ”Š å¼€å§‹æ”¶å¬ Clubdeck
            </button>

            <button class="mic-button" id="micButton" title="ç‚¹å‡»å¼€å§‹/åœæ­¢é€šè¯">
                ğŸ¤
            </button>

            <div class="volume-container">
                <div class="volume-label">
                    <span>ğŸ¤ éº¦å…‹é£éŸ³é‡</span>
                    <span id="micLevel">0%</span>
                </div>
                <div class="volume-meter">
                    <div class="volume-bar" id="micVolumeBar"></div>
                </div>
            </div>

            <div class="volume-container">
                <div class="volume-label">
                    <span>ğŸ”Š æ¥æ”¶éŸ³é‡</span>
                    <span id="speakerLevel">0%</span>
                </div>
                <div class="volume-meter">
                    <div class="volume-bar" id="speakerVolumeBar"></div>
                </div>
            </div>
        </div>

        <p class="info-text">ç‚¹å‡»ã€Œå¼€å§‹æ”¶å¬ã€æ”¶å¬ æˆ¿é—´ï¼Œç‚¹å‡»éº¦å…‹é£å‘è¨€</p>

        <div class="error-message" id="errorMessage"></div>

        <div class="nav-link">
            <a href="/static/debug.html">ğŸ”§ è°ƒè¯•é¢æ¿</a>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        class VoiceClient {
            constructor() {
                this.socket = null;
                this.clientId = null;
                this.audioContext = null;
                this.mediaStream = null;
                this.mediaStreamSource = null;
                this.scriptProcessor = null;
                this.playbackGain = null;
                
                this.isConnected = false;
                this.isMicActive = false;
                this.audioReady = false;
                
                this.sampleRate = 48000;
                this.channels = 2;
                this.bufferSize = 2048;
                
                this.noiseGateEnabled = true;
                this.noiseThreshold = 2;
                
                this.nextPlayTime = 0;
                this.playbackLatency = 0.05;
                
                // åŒå·¥æ¨¡å¼
                this.duplexMode = 'half';
                
                this.initSocket();
            }

            initSocket() {
                this.socket = io({ transports: ['websocket', 'polling'] });
                
                this.socket.on('connect', () => {
                    console.log('WebSocket å·²è¿æ¥');
                });

                this.socket.on('connected', (data) => {
                    this.clientId = data.client_id;
                    this.isConnected = true;
                    
                    // è·å–åŒå·¥æ¨¡å¼
                    if (data.duplex_mode) {
                        this.duplexMode = data.duplex_mode;
                        this.updateDuplexUI();
                    }
                    
                    this.updateUI();
                    console.log('å®¢æˆ·ç«¯ID:', this.clientId, 'åŒå·¥æ¨¡å¼:', this.duplexMode);
                });

                this.socket.on('disconnect', () => {
                    this.isConnected = false;
                    this.updateUI();
                    console.log('WebSocket æ–­å¼€');
                });

                this.socket.on('audio_from_clubdeck', (data) => {
                    this.handleIncomingAudio(data);
                });

                this.socket.on('connect_error', (error) => {
                    console.error('è¿æ¥é”™è¯¯:', error);
                });
            }

            updateUI() {
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                const clientIdEl = document.getElementById('clientId');
                const micButton = document.getElementById('micButton');
                
                if (statusDot) {
                    statusDot.className = 'status-dot' + (this.isConnected ? ' connected' : '');
                }
                if (statusText) {
                    statusText.textContent = this.isConnected ? 'å·²è¿æ¥' : 'æœªè¿æ¥';
                }
                if (clientIdEl) {
                    clientIdEl.textContent = this.clientId ? `ID: ${this.clientId.slice(0, 8)}...` : '';
                }
                
                // æ›´æ–°éº¦å…‹é£æŒ‰é’®çŠ¶æ€
                if (micButton) {
                    micButton.className = 'mic-button' + (this.isMicActive ? ' active' : '');
                }
            }

            updateDuplexUI() {
                const modeIndicator = document.getElementById('modeIndicator');
                const micButton = document.getElementById('micButton');
                
                if (this.duplexMode === 'half') {
                    if (modeIndicator) {
                        modeIndicator.textContent = 'ğŸ“» åŠåŒå·¥ (ä»…ç›‘å¬)';
                        modeIndicator.className = 'mode-indicator mode-half';
                    }
                    if (micButton) {
                        micButton.classList.add('hidden');
                    }
                } else {
                    if (modeIndicator) {
                        modeIndicator.textContent = 'ğŸ“ å…¨åŒå·¥ (åŒå‘é€šä¿¡)';
                        modeIndicator.className = 'mode-indicator mode-full';
                    }
                    if (micButton) {
                        micButton.classList.remove('hidden');
                    }
                }
            }

            initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate
                    });
                }
                
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                if (!this.playbackGain) {
                    this.playbackGain = this.audioContext.createGain();
                    this.playbackGain.connect(this.audioContext.destination);
                }
                
                this.audioReady = true;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                const btn = document.getElementById('listenButton');
                if (btn) {
                    btn.textContent = 'âœ… æ­£åœ¨æ”¶å¬ Clubdeck';
                    btn.classList.add('active');
                }
                
                console.log('éŸ³é¢‘å·²æ¿€æ´»');
            }

            async toggleMic() {
                if (this.isMicActive) {
                    this.stopMic();
                } else {
                    await this.startMic();
                }
            }

            async startMic() {
                if (this.duplexMode === 'half') {
                    console.log('åŠåŒå·¥æ¨¡å¼ï¼Œéº¦å…‹é£å·²ç¦ç”¨');
                    return;
                }
                
                try {
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: this.sampleRate,
                            channelCount: this.channels
                        }
                    });

                    this.initAudioContext();

                    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.mediaStream);
                    this.scriptProcessor = this.audioContext.createScriptProcessor(this.bufferSize, this.channels, this.channels);

                    this.scriptProcessor.onaudioprocess = (event) => {
                        if (!this.isMicActive) return;

                        const leftChannel = event.inputBuffer.getChannelData(0);
                        const rightChannel = this.channels > 1 && event.inputBuffer.numberOfChannels > 1 
                            ? event.inputBuffer.getChannelData(1) 
                            : leftChannel;
                        
                        const volume = this.calculateVolume(leftChannel);
                        this.updateMicMeter(volume);
                        
                        if (this.noiseGateEnabled && volume < this.noiseThreshold) {
                            return;
                        }

                        const int16Data = this.float32StereoToInt16(leftChannel, rightChannel);
                        const base64Data = this.arrayBufferToBase64(int16Data.buffer);

                        this.socket.emit('audio_data', { audio: base64Data, channels: this.channels });
                    };

                    this.mediaStreamSource.connect(this.scriptProcessor);
                    this.scriptProcessor.connect(this.audioContext.destination);

                    this.isMicActive = true;
                    this.updateUI();
                    console.log('éº¦å…‹é£å·²å¼€å¯');

                } catch (error) {
                    console.error('éº¦å…‹é£é”™è¯¯:', error);
                }
            }

            stopMic() {
                if (this.scriptProcessor) {
                    this.scriptProcessor.disconnect();
                    this.scriptProcessor = null;
                }
                if (this.mediaStreamSource) {
                    this.mediaStreamSource.disconnect();
                    this.mediaStreamSource = null;
                }
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                this.isMicActive = false;
                this.updateUI();
                console.log('éº¦å…‹é£å·²å…³é—­');
            }

            handleIncomingAudio(data) {
                try {
                    const int16Data = this.base64ToInt16Array(data.audio);
                    const channels = data.channels || this.channels;
                    const { left, right } = this.int16StereoToFloat32(int16Data, channels);

                    const volume = this.calculateVolume(left);
                    this.updateSpkMeter(volume);

                    if (this.audioReady) {
                        this.playAudioStereo(left, right);
                    }

                } catch (error) {
                    console.error('éŸ³é¢‘å¤„ç†é”™è¯¯:', error);
                }
            }

            playAudioStereo(leftData, rightData) {
                if (!this.audioContext) return;

                const buffer = this.audioContext.createBuffer(2, leftData.length, this.audioContext.sampleRate);
                buffer.getChannelData(0).set(leftData);
                buffer.getChannelData(1).set(rightData);

                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(this.playbackGain);
                
                const currentTime = this.audioContext.currentTime;
                if (this.nextPlayTime < currentTime) {
                    this.nextPlayTime = currentTime + this.playbackLatency;
                }
                
                source.start(this.nextPlayTime);
                this.nextPlayTime += buffer.duration;
            }

            updateMicMeter(volume) {
                const bar = document.getElementById('micVolumeBar');
                const level = document.getElementById('micLevel');
                if (bar) bar.style.width = Math.min(100, volume) + '%';
                if (level) level.textContent = volume.toFixed(0) + '%';
            }

            updateSpkMeter(volume) {
                const bar = document.getElementById('speakerVolumeBar');
                const level = document.getElementById('speakerLevel');
                if (bar) bar.style.width = Math.min(100, volume) + '%';
                if (level) level.textContent = volume.toFixed(0) + '%';
            }

            calculateVolume(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += Math.abs(data[i]);
                }
                return (sum / data.length) * 100 * 10;
            }

            float32StereoToInt16(left, right) {
                const length = left.length;
                const int16 = new Int16Array(length * 2);
                for (let i = 0; i < length; i++) {
                    int16[i * 2] = Math.max(-32768, Math.min(32767, Math.round(left[i] * 32767)));
                    int16[i * 2 + 1] = Math.max(-32768, Math.min(32767, Math.round(right[i] * 32767)));
                }
                return int16;
            }

            int16StereoToFloat32(int16Data, channels) {
                if (channels === 2) {
                    const length = int16Data.length / 2;
                    const left = new Float32Array(length);
                    const right = new Float32Array(length);
                    for (let i = 0; i < length; i++) {
                        left[i] = int16Data[i * 2] / 32768;
                        right[i] = int16Data[i * 2 + 1] / 32768;
                    }
                    return { left, right };
                } else {
                    const mono = new Float32Array(int16Data.length);
                    for (let i = 0; i < int16Data.length; i++) {
                        mono[i] = int16Data[i] / 32768;
                    }
                    return { left: mono, right: mono };
                }
            }

            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            base64ToInt16Array(base64) {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return new Int16Array(bytes.buffer);
            }
        }

        // åˆå§‹åŒ–
        let client = null;
        
        window.onload = () => {
            client = new VoiceClient();
            window.client = client;
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('listenButton').addEventListener('click', () => {
                client.initAudioContext();
            });
            
            const micButton = document.getElementById('micButton');
            if (micButton) {
                micButton.addEventListener('click', () => {
                    client.toggleMic();
                });
            }
        };
    </script>
</body>
</html>
