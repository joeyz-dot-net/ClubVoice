<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClubVoice WebRTC Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 100%;
            padding: 40px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .config-section {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .config-item {
            margin-bottom: 15px;
        }
        
        .config-item:last-child {
            margin-bottom: 0;
        }
        
        label {
            display: block;
            color: #333;
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            font-family: monospace;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
        .btn-primary:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn-secondary:disabled {
            background: #ddd;
            color: #999;
            cursor: not-allowed;
        }
        
        .status-section {
            background: #f0f8ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .status-item:last-child {
            margin-bottom: 0;
        }
        
        .status-label {
            color: #666;
            font-weight: 500;
        }
        
        .status-value {
            color: #333;
            font-family: monospace;
            text-align: right;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-indicator.active {
            background: #4caf50;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.inactive {
            background: #999;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .info-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-size: 12px;
            color: #856404;
            line-height: 1.5;
        }
        
        .log-section {
            background: #1e1e1e;
            border-radius: 6px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
            user-select: text;
            -webkit-user-select: text;
            cursor: text;
        }
        
        .log-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 8px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .copy-btn {
            background: #4a4a4a;
            border: none;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
        }
        
        .copy-btn:hover {
            background: #5a5a5a;
        }
        
        .log-entry {
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
            color: #d4d4d4;
            margin-bottom: 4px;
            word-break: break-all;
            user-select: text;
        }
        
        .log-entry.error {
            color: #f44747;
        }
        
        .log-entry.success {
            color: #4ec9b0;
        }
        
        .log-entry.info {
            color: #9cdcfe;
        }
        
        audio {
            width: 100%;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽµ ClubVoice WebRTC</h1>
        <p class="subtitle">Standalone WebRTC Audio Streamer Client</p>
        
        <div class="info-box">
            <strong>ðŸ“Œ Server:</strong> <span id="currentServer">â€”</span><br>
            <strong>ðŸ“Œ Peer ID:</strong> <span id="currentPeerId">â€”</span>
        </div>
        
        <div class="button-group">
            <button class="btn-primary" onclick="connectWebRTC()">Connect</button>
            <button class="btn-secondary" onclick="disconnect()">Disconnect</button>
            <button class="btn-secondary" onclick="checkStatus()">Status</button>
        </div>
        
        <div class="status-section" id="statusSection">
            <div class="status-item">
                <span class="status-label"><span class="status-indicator inactive" id="statusIndicator"></span>Connection Status</span>
                <span class="status-value" id="connectionStatus">Disconnected</span>
            </div>
            <div class="status-item">
                <span class="status-label">Server Status</span>
                <span class="status-value" id="serverStatus">Unknown</span>
            </div>
            <div class="status-item">
                <span class="status-label">Sample Rate</span>
                <span class="status-value" id="sampleRate">â€”</span>
            </div>
            <div class="status-item">
                <span class="status-label">Channels</span>
                <span class="status-value" id="channels">â€”</span>
            </div>
            <div class="status-item">
                <span class="status-label">Connected Clients</span>
                <span class="status-value" id="connectedClients">â€”</span>
            </div>
        </div>
        
        <div>
            <label>Audio Output</label>
            <audio id="audioOutput" controls autoplay></audio>
        </div>
        
        <div class="log-section">
            <div class="log-title">
                <span>ðŸ“‹ Log</span>
                <button class="copy-btn" onclick="copyLogs()">ðŸ“‹ Copy All</button>
            </div>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        let pc = null;
        let audioTrack = null;
        
        // Auto-generated values
        const SERVER_URL = window.location.origin;
        const PEER_ID = 'client_' + Math.random().toString(36).substr(2, 8);
        
        // Copy logs to clipboard
        function copyLogs() {
            const logContainer = document.getElementById('logContainer');
            const logs = Array.from(logContainer.children)
                .map(el => el.textContent)
                .join('\n');
            navigator.clipboard.writeText(logs).then(() => {
                log('Logs copied to clipboard', 'success');
            }).catch(err => {
                log('Failed to copy: ' + err, 'error');
            });
        }
        
        // Logging utility
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            entry.textContent = `[${time}] ${message}`;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 50 entries
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }
        
        async function connectWebRTC() {
            try {
                log(`Connecting to ${SERVER_URL} with peer ID: ${PEER_ID}...`);
                
                // é…ç½® ICE æœåŠ¡å™¨ï¼ˆåŒ…å« STUNï¼‰
                pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                });
                
                // Handle ICE candidates - wait for gathering to complete
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        log(`ICE candidate: ${event.candidate.candidate.substring(0, 50)}...`, 'info');
                    } else {
                        log('ICE gathering complete', 'success');
                    }
                };
                
                // Add transceiver to receive audio (recvonly direction)
                // This tells the server we want to receive audio
                pc.addTransceiver('audio', { direction: 'recvonly' });
                log('Added audio transceiver (recvonly)', 'info');
                
                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete (or timeout)
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                pc.removeEventListener('icegatheringstatechange', checkState);
                                resolve();
                            }
                        };
                        pc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 3 seconds
                        setTimeout(resolve, 3000);
                    }
                });
                
                log('Local offer created', 'info');
                
                // Send offer to server (with gathered ICE candidates)
                const response = await fetch(`${SERVER_URL}/offer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sdp: offer.sdp, pc_id: PEER_ID })
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const data = await response.json();
                log('Answer received from server', 'success');
                
                // Set up event handlers BEFORE setRemoteDescription
                pc.ontrack = (event) => {
                    log(`Track received: ${event.track.kind}`, 'success');
                    if (event.track.kind === 'audio') {
                        audioTrack = event.track;
                        const audioOutput = document.getElementById('audioOutput');
                        audioOutput.srcObject = event.streams[0];
                        
                        // Attempt to play audio
                        audioOutput.play().then(() => {
                            log('Audio playback started', 'success');
                        }).catch((e) => {
                            log(`Audio play failed: ${e.message}. Click play button.`, 'error');
                        });
                    }
                };
                
                pc.onconnectionstatechange = () => {
                    log(`Connection state: ${pc.connectionState}`, 'info');
                    updateConnectionStatus();
                };
                
                pc.oniceconnectionstatechange = () => {
                    log(`ICE state: ${pc.iceConnectionState}`, 'info');
                };
                
                // Set remote description (this may trigger ontrack)
                const answer = new RTCSessionDescription({
                    sdp: data.sdp,
                    type: 'answer'
                });
                await pc.setRemoteDescription(answer);
                
                log('Remote answer set', 'info');
                log('WebRTC connection established', 'success');
                updateConnectionStatus();
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                console.error('WebRTC error:', error);
                if (pc) {
                    pc.close();
                    pc = null;
                }
                updateConnectionStatus();
            }
        }
        
        async function disconnect() {
            try {
                if (pc) {
                    pc.close();
                    pc = null;
                    log('Disconnected', 'info');
                }
                
                const audioOutput = document.getElementById('audioOutput');
                audioOutput.srcObject = null;
                
                updateConnectionStatus();
            } catch (error) {
                log(`Disconnect error: ${error.message}`, 'error');
            }
        }
        
        async function checkStatus() {
            try {
                log('Checking server status...', 'info');
                const response = await fetch(`${SERVER_URL}/status`);
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                const data = await response.json();
                log(`Server status: ${data.status} (${data.peers} peer(s))`, 'success');
                
                // Update status display
                document.getElementById('serverStatus').textContent = data.status;
                document.getElementById('sampleRate').textContent = `${data.sample_rate} Hz`;
                document.getElementById('channels').textContent = data.channels;
                document.getElementById('connectedClients').textContent = data.peers;
                
            } catch (error) {
                log(`Status check error: ${error.message}`, 'error');
                document.getElementById('serverStatus').textContent = 'Error';
            }
        }
        
        function updateConnectionStatus() {
            const indicator = document.getElementById('statusIndicator');
            const statusValue = document.getElementById('connectionStatus');
            
            if (pc && (pc.connectionState === 'connected' || pc.iceConnectionState === 'connected')) {
                indicator.classList.remove('inactive');
                indicator.classList.add('active');
                statusValue.textContent = 'Connected';
            } else {
                indicator.classList.remove('active');
                indicator.classList.add('inactive');
                statusValue.textContent = 'Disconnected';
            }
        }
        
        // Auto check status on load and periodically
        window.addEventListener('load', () => {
            log('WebRTC client ready', 'info');
            
            // Update display
            document.getElementById('currentServer').textContent = SERVER_URL;
            document.getElementById('currentPeerId').textContent = PEER_ID;
            
            checkStatus();
            
            // Auto-refresh status every 5 seconds
            setInterval(() => {
                checkStatus();
            }, 5000);
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (pc) {
                pc.close();
            }
        });
    </script>
</body>
</html>
